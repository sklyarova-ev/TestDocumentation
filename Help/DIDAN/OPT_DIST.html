<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of OPT_DIST</title>
  <meta name="keywords" content="OPT_DIST">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">DIDAN</a> &gt; OPT_DIST.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for DIDAN&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>OPT_DIST
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function OPT_DIST </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">
 Latest revision 12.05.2019 

 Вычисление оптимального возмущения из подпространства для заданного 
 стационарного стационарного состояния 

 Внешние процедуры: Matrices, Ploter, COEF
 Папка с внешними процедурами:</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../DIDAN/Functions/Matrices.html" class="code" title="function [L,CM,M]=Matrices(RHS,Uss,coef,delta,vtau,scheme)">Matrices</a>	</li><li><a href="../DIDAN/Functions/Ploter.html" class="code" title="function Ploter(t,U,mark,iclean,h,v,varname,logind)">Ploter</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function MlI=MatrixPower(M,I,l)</a></li><li><a href="#_sub2" class="code">function [Q,R]=Get_Q(isub,mp,pmax,pwl,alpha,k1,delta)</a></li><li><a href="#_sub3" class="code">function Q=Get_pw_Q(pwl,mp,d)</a></li><li><a href="#_sub4" class="code">function Q=Get_exp_Q(pwl,mp,alpha,delta,it)</a></li><li><a href="#_sub5" class="code">function Q=Get_new_Q(pwl,mp,alpha,k1,delta,it)</a></li><li><a href="#_sub6" class="code">function [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)</a></li><li><a href="#_sub7" class="code">function [w]=Powmv(M,Q,k,v,C,vm,mp,it)</a></li><li><a href="#_sub8" class="code">function [w]=Powmvt(M,Q,k,v,C,vm,mp,it)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function OPT_DIST</a>
0002 <span class="comment">%</span>
0003 <span class="comment">% Latest revision 12.05.2019</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Вычисление оптимального возмущения из подпространства для заданного</span>
0006 <span class="comment">% стационарного стационарного состояния</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Внешние процедуры: Matrices, Ploter, COEF</span>
0009 <span class="comment">% Папка с внешними процедурами:</span>
0010 addpath([cd <span class="string">'/Functions/'</span>])
0011 <span class="comment">%</span>
0012 <span class="comment">% Внутренние процедуры: MatrixPower, Get_Q, Get_pw_Q, Get_exp_Q, Get_new_Q,</span>
0013 <span class="comment">%                       LanczLSV, Powmv, Powmvt</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% УСТАНОВКА ПАРАМЕТРОВ:</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% Загрузка стационарного состояния и задание параметров модели:</span>
0020 <span class="comment">%</span>
0021 [coef,vtau,varname]=COEF;
0022 load(<span class="string">'SSfile'</span>,<span class="string">'SSfinal'</span>);
0023 Uss=SSfinal{1,2};
0024 <span class="comment">%</span>
0025 T=70; <span class="comment">% время интегрирования</span>
0026 delta=5e-3; <span class="comment">% шаг сетки</span>
0027 scheme=2; <span class="comment">% схема интегрирования: 1 - неявный метод Эйлера,</span>
0028           <span class="comment">%                       2 - BDF2.</span>
0029 method=31; <span class="comment">% метод вычисления оптимального возмущения</span>
0030            <span class="comment">% 11 - примитивный алгоритм без вычисления M^l</span>
0031            <span class="comment">% 12 - примитивный алгоритм с вычислением M^l</span>
0032            <span class="comment">% 21 - Ланцош без вычисления M^l</span>
0033            <span class="comment">% 22 - Ланцош с вычислением M^l</span>
0034            <span class="comment">% 31 - метод последовательной максимизации без вычисления M^l</span>
0035            <span class="comment">% 32 - метод последовательной максимизации с вычислением M^l</span>
0036            <span class="comment">% параметры метода Ланцоша:</span>
0037                                       lanczmax = 20; lancztol = 1.e-9; 
0038 <span class="comment">%</span>
0039 l=50;  <span class="comment">% инкремент вычисления норм матриц</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% normindex=1; %выбор нормы: 1 - L2-норма, 2 - соболевская норма</span>
0042 W21weight=1; <span class="comment">%выбор веса призводной в соболевской норме, W21weight=0 даёт L_2 норму</span>
0043 inorm=2; <span class="comment">% веса локальной нормы: 1 - diagD=1, 2 - diagD=1/Uss</span>
0044 <span class="comment">%</span>
0045 diagDM=ones(1,size(Uss,1)); <span class="comment">% цена компонент решения</span>
0046 <span class="comment">%</span>
0047 ivar=[1,1,1,0,0,0,0,0,0,0]; <span class="comment">% какие компоненты варьировать (1), а какие нет (0)</span>
0048 <span class="comment">%</span>
0049 isub=[7,7,7,7,7,7,7,7,7,7]; <span class="comment">% подпространство возмущений для всех переменных:</span>
0050          <span class="comment">% 1 - все пространство</span>
0051          <span class="comment">% 2 - span{1,cos(2*pi*p*t/tau_p),sin(2*pi*p*t/tau_p)}, p=1,...,pmax</span>
0052          <span class="comment">% 3 - кусочно-постоянные функции</span>
0053          <span class="comment">% 4 - кусочно-линейные функции c соотношением длин подынтервалов</span>
0054          <span class="comment">% 5 - кусочно-экспоненциальные функции вида exp(alpha*(x-x0))</span>
0055                <span class="comment">% (рекомендованные показатели alpha: -12,-6,-1,0.5,1,5)</span>
0056          <span class="comment">% 6 - кусочно-экспоненциальные функции вида exp(alpha*(x-x0))-1</span>
0057                <span class="comment">% (рекомендованные показатели alpha: -12,-6,-1,0.5,1,5)</span>
0058          <span class="comment">% 7 - функции вида exp(alpha*(x-x0))-exp(k1*(x-x0))</span>
0059                <span class="comment">% с набором показателей таких, что (k1&lt;alpha)</span>
0060          <span class="comment">% 8 - функции вида exp(alpha*(x-x0))-exp(k1*(x-x0)) с занулением</span>
0061                <span class="comment">% в двух крайних правых узлах сетки.</span>
0062                <span class="comment">% с набором показателей таких, что(k1&lt;alpha)</span>
0063 <span class="comment">%</span>
0064 pmax=[0,0,0,0,0,0,0,0,0,0]; <span class="comment">%переменная pmax для каждой переменной в случае подпространства 2</span>
0065 <span class="comment">%</span>
0066 pwl=cell(1,size(Uss,1));  <span class="comment">%соотношение длин подинтервалов, на которые разбивается интервал (-tau_p,0) для</span>
0067                           <span class="comment">%каждой переменной (необходимо в случае пространств 3-8)</span>
0068 <span class="keyword">for</span> i=1:size(Uss,1)
0069     pwl{1,i}=ones(1,56);
0070 <span class="keyword">end</span>
0071 <span class="comment">%</span>
0072 alpha=cell(1,size(Uss,1)); <span class="comment">% параметры alpha в экспоненциальной зависимости в случае</span>
0073                            <span class="comment">% пространств 5-8. В случае пространств 1-4</span>
0074                            <span class="comment">% поставить alpha=0</span>
0075 <span class="keyword">for</span> i=1:size(Uss,1)
0076     alpha{1,i}=-3;
0077 <span class="keyword">end</span>
0078 <span class="comment">%</span>
0079 k1=cell(1,size(Uss,1)); <span class="comment">% параметры alpha в экспоненциальной зависимости в случае</span>
0080                         <span class="comment">% пространств 7-8. В случае пространств 1-6</span>
0081                         <span class="comment">% поставить k1=0</span>
0082 <span class="keyword">for</span> i=1:size(Uss,1)
0083     k1{1,i}=-9;
0084 <span class="keyword">end</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%interp1_method='spline'; % метод интерполяции: 'linear', 'spline', 'pchip'</span>
0088 <span class="comment">%</span>
0089 iclean=0;  <span class="comment">% предварительная чистка картинок</span>
0090 <span class="comment">%</span>
0091 marks={<span class="string">'r-'</span>,<span class="string">'b-'</span>,<span class="string">'g-'</span>}; <span class="comment">% маркеры для отрисовки максимальной амплификации и</span>
0092                    <span class="comment">% оптимального возмущения.</span>
0093 vp=2; <span class="comment">%количество картинок по вертикали</span>
0094 hp=5; <span class="comment">%количество картинок по горизонтали</span>
0095 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0096 <span class="comment">% Вывод значений параметров на экран:</span>
0097 fprintf(1,<span class="string">'T=%g\n'</span>,T);
0098 fprintf(1,<span class="string">'delta=%g\n'</span>,delta);
0099 <span class="comment">%</span>
0100 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0101 <span class="comment">% ИНИЦИАЛИЗАЦИЯ:</span>
0102 
0103 <span class="comment">%</span>
0104 N=ceil(T/(delta*l));
0105 K=N*l;
0106 vm=ceil(vtau/delta);
0107 mp=vm(end);
0108 <span class="comment">%</span>
0109 <span class="keyword">switch</span> inorm  <span class="comment">% веса локальной нормы:</span>
0110 <span class="keyword">case</span> 1
0111    diagD=ones(size(Uss,1),1);
0112 <span class="keyword">case</span> 2
0113    diagD=1./Uss;
0114 <span class="keyword">end</span>
0115 <span class="comment">%</span>
0116 <span class="comment">% Составление матрицы соболевской нормы</span>
0117 P=speye(mp);
0118 P(1,1)=0.5;
0119 P(mp,mp)=0.5;
0120 e = ones(mp,1);
0121 Diff = spdiags([-e 2*e -e], -1:1, mp, mp);
0122 Diff(1,1)=1;
0123 Diff(mp,mp)=1;
0124 <span class="comment">% Diff=sparse(-diag(ones(mp-1,1),-1)+2*diag(ones(mp,1))-diag(ones(mp-1,1),1));</span>
0125 <span class="comment">% Diff(1,1)=1;</span>
0126 <span class="comment">% Diff(mp,mp)=1;</span>
0127 P=chol(((W21weight)^2)*Diff/delta+P*delta);
0128     <span class="comment">%D=diag(diagD);</span>
0129     <span class="comment">%H=sparse(kron(P,D));</span>
0130 [L,C,~]=<a href="../DIDAN/Functions/Matrices.html" class="code" title="function [L,CM,M]=Matrices(RHS,Uss,coef,delta,vtau,scheme)">Matrices</a>(Uss,coef,delta,vtau,scheme);
0131 <span class="keyword">for</span> i=1:size(C,2)
0132     C{1,i}=diag(diagD)*C{1,i}*diag(1./diagD);
0133 <span class="keyword">end</span>
0134 nov=size(C{1,1},1);
0135 <span class="keyword">if</span>(method==12||method==22||method==32)
0136    M=sparse(nov+1:1:nov*mp,1:1:nov*mp-nov,ones(nov*mp-nov,1),nov*mp,nov*mp,nov*mp-nov);
0137    M(1:nov,1:nov)=sparse(C{1,1});
0138    M(1:nov,nov+1:2*nov)=sparse(C{1,2});
0139    <span class="keyword">for</span> i=3:(size(vtau,1)+2)
0140        M(1:nov,(nov*vm(i-2)-nov+1):(nov*vm(i-2)))=M(1:nov,(nov*vm(i-2)-nov+1):(nov*vm(i-2)))+sparse(C{1,i});
0141    <span class="keyword">end</span>
0142    Ml=<a href="#_sub1" class="code" title="subfunction MlI=MatrixPower(M,I,l)">MatrixPower</a>(M,speye(size(M)),l);
0143    clear M;
0144 <span class="keyword">else</span>
0145    Ml=[]; 
0146 <span class="keyword">end</span>
0147 <span class="comment">%</span>
0148 Q=[];
0149 I=eye(nov);
0150 Rvfinal=cell(1,size(Uss,1));
0151 Qvfinal=cell(1,size(Uss,1));
0152 k=1;
0153 <span class="keyword">while</span> ~ivar(k)
0154     k=k+1;
0155 <span class="keyword">end</span>
0156 <span class="keyword">for</span> i=k:nov
0157     <span class="keyword">if</span>(ivar(i))
0158         [Qv,Rv]=<a href="#_sub2" class="code" title="subfunction [Q,R]=Get_Q(isub,mp,pmax,pwl,alpha,k1,delta)">Get_Q</a>(isub(i),mp,pmax,pwl{1,i},alpha{1,i},k1{1,i},delta);
0159         Q=[Q,kron(Qv,I(:,i))];
0160         Rvfinal{1,i}=Rv;
0161         Qvfinal{1,i}=Qv;
0162         [~,R1]=qr(P*Qv,0);
0163         <span class="keyword">if</span> i==k
0164             R=inv(R1);
0165         <span class="keyword">else</span>
0166             R=blkdiag(R,inv(R1));
0167         <span class="keyword">end</span>
0168     <span class="keyword">end</span>
0169 <span class="keyword">end</span>
0170     <span class="comment">%Qnew=[kron(Q1,I(:,1)),kron(Q2,I(:,2)),kron(Q3,I(:,3)),kron(Q4,I(:,4))];</span>
0171     <span class="comment">%Rnew=blkdiag(diagD(1)*R1,diagD(2)*R2,diagD(3)*R3,diagD(4)*R4);</span>
0172     Rinv=R;
0173     HM=sparse(kron(P,diag(diagDM)));
0174 <span class="comment">%</span>
0175 t=(0:l:K)*delta;
0176 Gamma=ones(size(t))*norm(HM*Q*Rinv,2); 
0177 <span class="keyword">if</span>(method&lt;30)
0178 tic
0179 <span class="comment">% Расчет максимальной амплификации:</span>
0180 E=Q*Rinv;
0181 <span class="keyword">for</span> k=2:N+1
0182    <span class="keyword">if</span>(method==11)
0183       <span class="keyword">for</span> j=1:l 
0184          X=C{1,1}*E(1:nov,:)+C{1,2}*E(nov+1:2*nov,:);
0185          <span class="keyword">for</span> r=3:size(C,2)
0186              mi=vm(r-2);
0187              X=X+C{1,r}*E(nov*mi-nov+1:nov*mi,:);
0188          <span class="keyword">end</span>
0189          E(nov+1:nov*mp,:)=E(1:nov*mp-nov,:);
0190          E(1:nov,:)=X;
0191       <span class="keyword">end</span>
0192     Gamma(k)=norm(full(HM*E),2);
0193    <span class="keyword">elseif</span>(method==12)
0194       E=Ml*E;
0195       Gamma(k)=norm(full(HM*E),2);
0196    <span class="keyword">elseif</span>(method==21||method==22) 
0197       E=Q*Rinv;
0198       eta=randn(size(E,2),1); eta=eta/norm(eta); 
0199       <span class="keyword">if</span>(method==21)
0200          [Gamma(k)]=<a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,<span class="keyword">...</span>
0201                              (k-1)*l,lanczmax,lancztol,C,vm,1);
0202       <span class="keyword">elseif</span>(method==22)
0203          [Gamma(k)]=<a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,<span class="keyword">...</span>
0204                               k-1,lanczmax,lancztol,C,vm,2); 
0205       <span class="keyword">end</span>    
0206    <span class="keyword">end</span> 
0207    fprintf(1,<span class="string">'t=%g, Gamma=%d\n'</span>,t(k),Gamma(k));
0208 <span class="keyword">end</span>  
0209 toc
0210 <span class="comment">%</span>
0211 <span class="comment">% Расчет оптимального возмущения:</span>
0212 [~,kopt]=max(Gamma);
0213 <span class="keyword">if</span>(method==11||method==12)
0214 E=Q*Rinv; 
0215    <span class="keyword">for</span> k=2:kopt
0216       <span class="keyword">if</span>(method==11)
0217          <span class="keyword">for</span> j=1:l 
0218             X=C{1,1}*E(1:nov,:)+C{1,2}*E(nov+1:2*nov,:);
0219             <span class="keyword">for</span> i=3:size(C,2)
0220             X=X+C{1,i}*E(nov*vm(i-2)-nov+1:nov*vm(i-2),:);
0221             <span class="keyword">end</span>
0222             E(nov+1:nov*mp,:)=E(1:nov*mp-nov,:);
0223             E(1:nov,:)=X;
0224          <span class="keyword">end</span>   
0225       <span class="keyword">elseif</span>(method==12||method==22) 
0226          E=Ml*E;
0227       <span class="keyword">end</span>   
0228       fprintf(1,<span class="string">'t=%g\n'</span>,t(k));
0229    <span class="keyword">end</span>
0230    [~,Sigma,eta]=svd(full(HM*E),0);
0231    Sigma_1=Sigma(1,1);
0232    Sigma_2=Sigma(2,2);
0233    eta=eta(:,1);
0234 <span class="keyword">elseif</span>(method==21||method==22)
0235    E=Q*Rinv; 
0236    eta=randn(size(E,2),1); eta=eta/norm(eta);
0237    <span class="keyword">if</span>(method==21)
0238          [Sigma_1,eta,~,~,Sigma_2]=<a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,<span class="keyword">...</span>
0239                           (kopt-1)*l,lanczmax,lancztol,C,vm,1);
0240    <span class="keyword">elseif</span>(method==22)
0241          [Sigma_1,eta,~,~,Sigma_2]=<a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,<span class="keyword">...</span>
0242                               kopt-1,lanczmax,lancztol,C,vm,2); 
0243    <span class="keyword">end</span>   
0244 <span class="keyword">end</span>
0245 <span class="keyword">else</span>
0246 tic
0247 <span class="comment">% Последовательная максимизация:</span>
0248    E=Q*Rinv;  
0249    k=0;
0250    knew=ceil(N/2)+1;
0251    <span class="keyword">while</span>(k~=knew)
0252       eta=randn(size(E,2),1); eta=eta/norm(eta);
0253       k=knew;    
0254       <span class="keyword">if</span>(method==31)
0255          [Sigma_1,eta,~,~,Sigma_2]=<span class="keyword">...</span>
0256             <a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,(k-1)*l,lanczmax,lancztol,C,vm,1);
0257       <span class="keyword">elseif</span>(method==32)
0258          [Sigma_1,eta,~,~,Sigma_2]=<span class="keyword">...</span>
0259             <a href="#_sub6" class="code" title="subfunction [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)">LanczLSV</a>(HM,Ml,E,eta,k-1,lanczmax,lancztol,C,vm,2); 
0260       <span class="keyword">end</span>
0261       fprintf(1,<span class="string">'t=%g, Gamma=%d\n'</span>,t(k),Sigma_1);
0262       w=E*eta;  
0263       <span class="keyword">for</span> j=2:N+1
0264          <span class="keyword">if</span>(method==31) 
0265             <span class="keyword">for</span> jj=1:l 
0266                x=C{1,1}*w(1:nov)+C{1,2}*w(nov+1:2*nov);
0267                <span class="keyword">for</span> i=3:size(C,2)
0268                    x=x+C{1,i}*w(nov*vm(i-2)-nov+1:nov*vm(i-2));
0269                <span class="keyword">end</span>
0270                w(nov+1:nov*mp)=w(1:nov*mp-nov);
0271                w(1:nov)=x;
0272             <span class="keyword">end</span> 
0273          <span class="keyword">elseif</span>(method==32) 
0274             w=Ml*w;
0275          <span class="keyword">end</span>
0276          Gamma(j)=norm(full(HM*w),2);    
0277       <span class="keyword">end</span> 
0278 <span class="comment">%       figure(7)</span>
0279 <span class="comment">%       plot(t,Gamma,marks{1})</span>
0280 <span class="comment">%        xlabel('$t$','Interpreter','latex');</span>
0281 <span class="comment">%        title('$\Gamma(t)$','Interpreter','latex');</span>
0282 <span class="comment">%       hold on</span>
0283       [~,knew]=max(Gamma);
0284    <span class="keyword">end</span>
0285    toc
0286 <span class="keyword">end</span> 
0287 
0288 <span class="comment">%</span>
0289 figure(7)
0290 <span class="keyword">if</span>(iclean) 
0291   hold off
0292 <span class="keyword">end</span>    
0293 plot(t,Gamma,marks{1});
0294 xlabel(<span class="string">'$t$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);           
0295       title(<span class="string">'$\Gamma(t)$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);
0296 hold on
0297 [~,kopt]=max(Gamma);
0298 fprintf(1,<span class="string">'topt=%g, Gammaopt=%d\n'</span>,t(kopt),Gamma(kopt));
0299 fprintf(1,<span class="string">'Sigma_1=%d\n'</span>,Sigma_1);
0300 fprintf(1,<span class="string">'Sigma_2=%d\n'</span>,Sigma_2);
0301 <span class="comment">%</span>
0302     Ud=reshape(Q*(Rinv*eta),nov,mp); 
0303 <span class="comment">% Ud(2:3,m+1:end)=zeros(size(Ud(2:3,m+1:end))); % обнуление компонент,</span>
0304 <span class="comment">% Ud(4,3:end)=zeros(size(Ud(4,3:end)));         % неиспользуемых при</span>
0305 <span class="comment">%                                               % численном интегрировании</span>
0306 Ud=Ud(:,mp:-1:1); 
0307 Ud(~ivar,:)=zeros(size(Ud(~ivar,:)));
0308 
0309 Ud=diag(1./diagD)*Ud; <span class="comment">% оптимальное возмущение</span>
0310 <span class="comment">%</span>
0311 <span class="comment">% Интегрирование оптимального возмущения:</span>
0312 <span class="keyword">if</span> (W21weight==0)
0313     W21weight=1;
0314 <span class="keyword">end</span>    
0315 t=(0:1:K)*delta;
0316 v=diag(diagD)*Ud;
0317 U=zeros(nov,mp+K);
0318 U(:,1:mp)=v(:,1:mp);
0319 GammaL2=zeros(size(t));
0320 GammaW21=zeros(size(t));
0321 GammaL2(1)=sum(sum(delta*(diag(diagDM).^2)*(v(:,1:mp-1).^2+v(:,2:mp).^2)/2));
0322 GammaW21(1)=GammaL2(1)+(W21weight^2)*sum(sum(diag(diagDM).^2)*(v(:,2:mp)-v(:,1:mp-1)).^2/delta);
0323 <span class="keyword">for</span> k=mp+1:mp+K
0324    U(:,k)=C{1,1}*U(:,k-1)+C{1,2}*U(:,k-2);
0325    <span class="keyword">for</span> i=3:size(C,2)
0326        U(:,k)=U(:,k)+C{1,i}*U(:,k-vm(i-2));
0327    <span class="keyword">end</span>
0328    ww=delta*((norm(diag(diagDM)*U(:,k),2)^2)/2+<span class="keyword">...</span>
0329        (norm(diag(diagDM)*U(:,k-1),2)^2)/2-(norm(diag(diagDM)*U(:,k-mp),2)^2)/2-<span class="keyword">...</span>
0330                                  (norm(diag(diagDM)*U(:,k-mp+1),2)^2)/2);
0331    GammaL2(k-mp+1)=GammaL2(k-mp)+ww;
0332    GammaW21(k-mp+1)=GammaW21(k-mp)+ww+<span class="keyword">...</span>
0333            (W21weight^2)*delta*((norm(diag(diagDM)*((U(:,k)-U(:,k-1))/delta),2)^2)-<span class="keyword">...</span>
0334                  (norm(diag(diagDM)*((U(:,k-mp+1)-U(:,k-mp))/delta),2)^2));
0335 <span class="keyword">end</span> 
0336 plot(t,sqrt(GammaL2),marks{2})
0337 plot(t,sqrt(GammaW21),marks{3})
0338 hold on
0339 <span class="comment">%</span>
0340 <span class="comment">% Состав оптимального возмущения:</span>
0341 figure(5)
0342 td=(0:-1:-mp+1)*delta;
0343 <span class="keyword">for</span> i=1:nov
0344 <span class="keyword">if</span>(ivar(i))
0345    v=Ud(i,mp:-1:1)'/norm(Ud(i,mp:-1:1),2);
0346    nam=varname{1,i}(2:end-1);
0347    fprintf(<span class="string">'состав возмущения для компоненты %s'</span>,nam);
0348    spectrum=Rvfinal{1,i}\(Qvfinal{1,i}'*v)
0349    fprintf(1,<span class="string">'err=%d\n'</span>,norm(Qvfinal{1,i}*Rvfinal{1,i}*spectrum-v,2));
0350     subplot(vp,hp,i)
0351    <span class="keyword">if</span>(iclean) 
0352        hold off
0353    <span class="keyword">end</span>    
0354    <span class="keyword">for</span> k=1:size(Rvfinal{1,i},2)
0355       plot(td,-Qvfinal{1,i}*Rvfinal{1,i}(:,k)*spectrum(k),marks{2})
0356       xlabel(<span class="string">'$t$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);           
0357       title(varname{1,i},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>); 
0358       hold on
0359    <span class="keyword">end</span>    
0360 <span class="keyword">end</span>
0361 <span class="keyword">end</span>
0362 <span class="comment">%</span>
0363 <span class="comment">% Дополнение слева и нормировка:</span>
0364 td=(-mp:1:0)*delta;
0365 <span class="comment">%Ud=interp1((-mp+1:1:0)*delta,Ud',td,interp1_method)';</span>
0366 Ud=[zeros(nov,1),Ud];
0367 Ud(~ivar,:)=zeros(size(Ud(~ivar,:)));
0368 Ud2=(diag(diagD)*Ud).^2;
0369 norm2Ud=zeros(nov,1);
0370 <span class="keyword">for</span> i=1:(size(td,2)-1)
0371     norm2Ud=norm2Ud+(td(i+1)-td(i))*(Ud2(:,i)+Ud2(:,i+1))/2;
0372 <span class="keyword">end</span>
0373 c=1.0/sqrt(sum(norm2Ud));
0374 Ud=c*Ud;
0375 norm2Ud=sqrt(norm2Ud);
0376 <span class="keyword">for</span> i=1:size(Uss,1)
0377     nam=varname{1,i}(2:end-1);
0378     fprintf(<span class="string">'норма компоненты %s=%d\n'</span>,nam,c*norm2Ud(i));
0379 <span class="keyword">end</span>
0380 normW21Ud=zeros(nov,1);
0381 <span class="keyword">for</span> i=1:(size(td,2)-1)
0382     normW21Ud=normW21Ud+(diag(diagD)*(Ud(:,i+1)-Ud(:,i))).^2/delta;
0383 <span class="keyword">end</span>
0384 normW21Ud=sqrt(1.0+sum(normW21Ud));
0385 <span class="comment">%</span>
0386 <span class="comment">% Выбор знака (вирусная нагрузка увеличивается при t=0+0):</span>
0387 s=L{1,1}(1,:)*Ud(:,mp);
0388 <span class="keyword">for</span> i=2:size(L,2)
0389     s=s+L{1,i}(1,:)*Ud(:,mp-vm(i-1)+1);
0390 <span class="keyword">end</span>
0391 <span class="keyword">if</span>(s&lt;0)
0392    Ud=-Ud; 
0393 <span class="keyword">end</span> 
0394 <span class="comment">%</span>
0395 <span class="comment">% Отрисовка и сохранение оптимального возмущения:</span>
0396 figure(6)
0397 <a href="../DIDAN/Functions/Ploter.html" class="code" title="function Ploter(t,U,mark,iclean,h,v,varname,logind)">Ploter</a>(td,Ud,marks{2},iclean,hp,vp,varname)
0398 save(<span class="string">'ODfile'</span>,<span class="string">'Ud'</span>,<span class="string">'td'</span>,<span class="string">'normW21Ud'</span>);
0399 
0400 
0401 <a name="_sub1" href="#_subfunctions" class="code">function MlI=MatrixPower(M,I,l)</a>
0402 <span class="comment">%</span>
0403 <span class="comment">% Latest revision 02.01.2017</span>
0404 <span class="comment">%</span>
0405 <span class="comment">% MlI=M^l*I</span>
0406 <span class="comment">%</span>
0407 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0408 b=dec2bin(l);
0409 b=b(end:-1:1);
0410 <span class="keyword">if</span>(bin2dec(b(1))==1)
0411    MlI=M*I;
0412 <span class="keyword">else</span>
0413    MlI=I; 
0414 <span class="keyword">end</span>   
0415 P=M;
0416 <span class="keyword">for</span> j=2:size(b,2)
0417    P=P*P;
0418    <span class="keyword">if</span>(bin2dec(b(j))==1)
0419       MlI=P*MlI; 
0420    <span class="keyword">end</span>   
0421 <span class="keyword">end</span>
0422 
0423 <a name="_sub2" href="#_subfunctions" class="code">function [Q,R]=Get_Q(isub,mp,pmax,pwl,alpha,k1,delta)</a>
0424 <span class="comment">%</span>
0425 <span class="comment">% Latest revision 24.06.2017</span>
0426 <span class="comment">%</span>
0427 <span class="comment">% Формирование ортонормированного базиса в подпространтстве, из которого</span>
0428 <span class="comment">% ищется оптимальное возмущение.</span>
0429 <span class="comment">%</span>
0430 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0431 <span class="keyword">switch</span> isub
0432 <span class="keyword">case</span> 1
0433    Q=eye(mp,mp);  
0434 <span class="keyword">case</span> 2 
0435    Q=ones(mp,1+2*pmax); 
0436    <span class="keyword">for</span> p=1:pmax
0437       Q(:,2*p)=cos((2*pi*p*(1:1:mp)')/mp);  
0438       Q(:,2*p+1)=sin((2*pi*p*(1:1:mp)')/mp);  
0439    <span class="keyword">end</span>
0440 <span class="keyword">case</span> 3
0441    Q=<a href="#_sub3" class="code" title="subfunction Q=Get_pw_Q(pwl,mp,d)">Get_pw_Q</a>(pwl,mp,-1);   
0442 <span class="keyword">case</span> 4
0443    Q=<a href="#_sub3" class="code" title="subfunction Q=Get_pw_Q(pwl,mp,d)">Get_pw_Q</a>(pwl,mp,1);      
0444 <span class="keyword">case</span> 5
0445    Q=<a href="#_sub4" class="code" title="subfunction Q=Get_exp_Q(pwl,mp,alpha,delta,it)">Get_exp_Q</a>(pwl,mp,alpha,delta,0);
0446 <span class="keyword">case</span> 6
0447    Q=<a href="#_sub4" class="code" title="subfunction Q=Get_exp_Q(pwl,mp,alpha,delta,it)">Get_exp_Q</a>(pwl,mp,alpha,delta,1);   
0448 <span class="keyword">case</span> 7
0449    Q=<a href="#_sub5" class="code" title="subfunction Q=Get_new_Q(pwl,mp,alpha,k1,delta,it)">Get_new_Q</a>(pwl,mp,alpha,k1,delta,0); 
0450 <span class="keyword">case</span> 8
0451     Q=<a href="#_sub5" class="code" title="subfunction Q=Get_new_Q(pwl,mp,alpha,k1,delta,it)">Get_new_Q</a>(pwl,mp,alpha,k1,delta,1);
0452 <span class="keyword">end</span>
0453 [Q,R]=qr(Q,0);
0454 
0455 <a name="_sub3" href="#_subfunctions" class="code">function Q=Get_pw_Q(pwl,mp,d)</a>
0456 <span class="comment">%</span>
0457 <span class="comment">% Latest revision 17.05.2017</span>
0458 <span class="comment">%</span>
0459 <span class="comment">% Формирование ортонормированного базиса в подпространтстве</span>
0460 <span class="comment">% кусочно-постоянных (d=-1 или 0) и кусочно-линейных (d=1) функций</span>
0461 <span class="comment">% в интервалах с длинами, заданными в массиве pwl.</span>
0462 <span class="comment">%</span>
0463 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0464 npwl=size(pwl,2);
0465 pwl=pwl(npwl:-1:1);
0466 n=zeros(1,npwl+1);
0467 pwls=sum(pwl);
0468 <span class="keyword">for</span> j=2:npwl
0469    n(j)=round((sum(pwl(1:j-1))*mp)/pwls);
0470 <span class="keyword">end</span>
0471 n(npwl+1)=mp;
0472 <span class="keyword">if</span>(d==-1)
0473    Q=zeros(mp,npwl);
0474    <span class="keyword">for</span> j=1:npwl
0475       <span class="keyword">if</span>(n(j+1)-n(j)==0)
0476          disp(<span class="string">'слишком мелкое разбиение [-mp+1:0] на подынтервалы'</span>)
0477          STOP
0478       <span class="keyword">end</span>    
0479       Q(1:n(j+1),j)=1;
0480    <span class="keyword">end</span>
0481 <span class="keyword">elseif</span>(d==0)
0482    Q=zeros(mp,npwl);
0483    <span class="keyword">for</span> j=1:npwl
0484       <span class="keyword">if</span>(n(j+1)-n(j)==0)
0485          disp(<span class="string">'слишком мелкое разбиение [-mp+1:0] на подынтервалы'</span>)
0486          STOP
0487       <span class="keyword">end</span>    
0488       Q(n(j)+1:n(j+1),j)=1;
0489    <span class="keyword">end</span>   
0490 <span class="keyword">elseif</span>(d==1)
0491    Q=zeros(mp,npwl+1);
0492    n(1)=1;
0493    Q(n(1):n(2),1)=(n(2)-n(1):-1:0)/(n(2)-n(1));
0494    Q(n(npwl):n(npwl+1),npwl+1)=(0:1:n(npwl+1)-n(npwl))/(n(npwl+1)-n(npwl));
0495    <span class="keyword">for</span> j=2:npwl
0496       <span class="keyword">if</span>(n(j)-n(j-1)&lt;=0||n(j+1)-n(j)&lt;=0)
0497          disp(<span class="string">'слишком мелкое разбиение [-mp+1:0] на подынтервалы'</span>)
0498          STOP
0499       <span class="keyword">end</span>    
0500       Q(n(j-1):n(j),j)=(0:1:n(j)-n(j-1))/(n(j)-n(j-1));
0501       Q(n(j):n(j+1),j)=(n(j+1)-n(j):-1:0)/(n(j+1)-n(j));
0502    <span class="keyword">end</span>
0503 <span class="keyword">end</span>
0504    
0505 <a name="_sub4" href="#_subfunctions" class="code">function Q=Get_exp_Q(pwl,mp,alpha,delta,it) </a>
0506 <span class="comment">%</span>
0507 <span class="comment">% Latest revision 24.06.2017</span>
0508 <span class="comment">%</span>
0509 <span class="comment">% Формирование ортонормированного базиса в подпространтстве</span>
0510 <span class="comment">% кусочно-экспоненциальных функций вида exp(alpha*(x-x0)) (it=0) либо</span>
0511 <span class="comment">% exp(alpha*(x-x0))-1 (it=1) в интервалах с длинами, заданными</span>
0512 <span class="comment">% в массиве pwl, и с показателями экспонент, заданными в массиве alpha.</span>
0513 <span class="comment">%</span>
0514 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0515 npwl=size(pwl,2);
0516 nalpha=size(alpha,2);
0517 Q=<a href="#_sub3" class="code" title="subfunction Q=Get_pw_Q(pwl,mp,d)">Get_pw_Q</a>(pwl,mp,-1);
0518 QN=zeros(mp,npwl,nalpha);
0519 <span class="keyword">for</span> i=1:nalpha
0520    QN(:,:,i)=diag(exp(alpha(i)*(0:-1:-mp+1)*delta))*Q;
0521    <span class="keyword">if</span>(it==1)
0522       <span class="keyword">for</span> j=1:npwl
0523          nz=sum(QN(:,j,i)==0);
0524          QN(1:end-nz,j,i)=QN(1:end-nz,j,i)-QN(end-nz,j,i);
0525       <span class="keyword">end</span>
0526    <span class="keyword">end</span>   
0527 <span class="keyword">end</span>
0528 Q=reshape(QN,mp,npwl*nalpha);
0529 <span class="comment">%figure(7)</span>
0530 <span class="comment">%plot((0:-1:-mp+1)*delta,Q(:,2),'r-');</span>
0531 <span class="comment">%disp(Q);</span>
0532 <span class="comment">% нормировка столбцов</span>
0533 <span class="keyword">for</span> k=1:npwl*nalpha
0534    Q(:,k)=Q(:,k)/norm(Q(:,k),2);
0535 <span class="keyword">end</span>
0536 
0537 <a name="_sub5" href="#_subfunctions" class="code">function Q=Get_new_Q(pwl,mp,alpha,k1,delta,it) </a>
0538 <span class="comment">%</span>
0539 <span class="comment">% Latest revision 06.10.2017</span>
0540 <span class="comment">%</span>
0541 <span class="comment">% Формирование ортонормированного базиса в подпространтстве</span>
0542 <span class="comment">% функций вида exp(alpha*(x-x0))-exp(k1*(x-x0)) в интервалах с длинами, заданными</span>
0543 <span class="comment">% в массиве pwl, и с показателями экспонент, заданными в массивах alpha и k1.</span>
0544 <span class="comment">% it=1 =&gt; зануление в двух крайних правых узлах сетки.</span>
0545 <span class="comment">%</span>
0546 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0547 npwl=size(pwl,2);
0548 pwl=pwl(npwl:-1:1);
0549 n=zeros(1,npwl+1);
0550 pwls=sum(pwl);
0551 
0552 <span class="keyword">for</span> j=2:npwl
0553    n(j)=round((sum(pwl(1:j-1))*mp)/pwls);
0554 <span class="keyword">end</span>
0555 n(npwl+1)=mp;
0556 Q=zeros(mp,npwl);
0557 <span class="keyword">for</span> j=1:npwl
0558    <span class="keyword">if</span>(n(j+1)-n(j)==0)
0559          disp(<span class="string">'слишком мелкое разбиение [-mp+1:0] на подынтервалы'</span>)
0560          STOP
0561    <span class="keyword">end</span>    
0562    Q(n(j+1):-1:1,j)=exp(alpha*(0:1:n(j+1)-1)*delta)-exp(k1*(0:1:n(j+1)-1)*delta);
0563 <span class="keyword">end</span>
0564 <span class="keyword">if</span> (it==1)
0565     Q(1:2,:)=0;
0566 <span class="keyword">end</span>
0567 <span class="keyword">for</span> k=1:npwl
0568    Q(:,k)=Q(:,k)/norm(Q(:,k),2);
0569 <span class="keyword">end</span>
0570 
0571 
0572 <a name="_sub6" href="#_subfunctions" class="code">function [s,vv,l,nq,s2]=LanczLSV(D,M,Q,v,k,lmax,ltol,C,vm,it)</a>
0573 <span class="comment">%</span>
0574 <span class="comment">% Latest revision 30.05.2017</span>
0575 <span class="comment">%</span>
0576 <span class="comment">% Lanczos for computing the largest singular value of D*M^k*Q</span>
0577 <span class="comment">%</span>
0578 <span class="comment">% внутренние процедуры: Powmv, Powmvt</span>
0579 <span class="comment">%</span>
0580 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0581 l=0;
0582 log=lmax&gt;=2;
0583 s2=0;
0584 mp=vm(end);
0585 <span class="keyword">if</span>(log)
0586    n=size(Q,2);
0587    q=zeros(n,lmax-1);
0588    q(:,1)=v/norm(v,2);
0589    qold=zeros(n,1);
0590    H=zeros(lmax-1,lmax-1);
0591    beta=0.0;
0592    s=0;
0593    sold=0;
0594    <span class="keyword">while</span> (s&gt;=(1.0+ltol)*sold&amp;&amp;log)
0595       l=l+1;
0596       sold=s; 
0597       vv=D*<a href="#_sub7" class="code" title="subfunction [w]=Powmv(M,Q,k,v,C,vm,mp,it)">Powmv</a>(M,Q,k,q(:,l),C,vm,mp,it);
0598       <span class="keyword">for</span> i=1:size(C,2)
0599           C{1,i}=C{1,i}';
0600       <span class="keyword">end</span>
0601       v=<a href="#_sub8" class="code" title="subfunction [w]=Powmvt(M,Q,k,v,C,vm,mp,it)">Powmvt</a>(M,Q,k,D'*vv,C,vm,mp,it);
0602       <span class="keyword">for</span> i=1:size(C,2)
0603           C{1,i}=C{1,i}';
0604       <span class="keyword">end</span>
0605       v=v-beta*qold;
0606       alpha=q(:,l)'*v;
0607       v=v-alpha*q(:,l);
0608       H(l,l)=alpha;
0609       s=sqrt(max(eig(H(1:l,1:l))));
0610       beta=norm(v,2);
0611       <span class="keyword">if</span>(beta==0.0||l==lmax-1)
0612          log=0; 
0613       <span class="keyword">else</span>
0614          qold=q(:,l);
0615          q(:,l+1)=v/beta;
0616          H(l+1,l)=beta;
0617          H(l,l+1)=beta;
0618       <span class="keyword">end</span>   
0619    <span class="keyword">end</span> 
0620    [p,es]=eig(H(1:l,1:l));
0621    [~,ii]=sort(diag(es),<span class="string">'descend'</span>);
0622    <span class="keyword">if</span>(l&gt;1)
0623       s2=sqrt(es(ii(2),ii(2)));
0624    <span class="keyword">else</span>
0625       s2=0.;
0626    <span class="keyword">end</span>    
0627    v=q(:,1:l)*p(:,ii(1));
0628    q=q(:,1:l)'*q(:,1:l);
0629    nq=norm(eye(size(q))-q,2);
0630 <span class="keyword">end</span>
0631 
0632 <span class="comment">% one step of the power method</span>
0633 vv=D*<a href="#_sub7" class="code" title="subfunction [w]=Powmv(M,Q,k,v,C,vm,mp,it)">Powmv</a>(M,Q,k,v,C,vm,mp,it);
0634 s=norm(vv,2);
0635 v=vv/s;
0636 <span class="keyword">for</span> i=1:size(C,2)
0637     C{1,i}=C{1,i}';
0638 <span class="keyword">end</span>
0639 vv=<a href="#_sub8" class="code" title="subfunction [w]=Powmvt(M,Q,k,v,C,vm,mp,it)">Powmvt</a>(M,Q,k,D'*v,C,vm,mp,it);
0640 s=norm(vv,2);
0641 vv=vv/s;
0642 l=l+1;
0643 
0644 
0645 
0646 <a name="_sub7" href="#_subfunctions" class="code">function [w]=Powmv(M,Q,k,v,C,vm,mp,it)</a>
0647 <span class="comment">%</span>
0648 <span class="comment">% Latest revision 02.03.2017</span>
0649 <span class="comment">%</span>
0650 <span class="comment">% compute w=M^k*Q*v</span>
0651 <span class="comment">%</span>
0652 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0653 w=Q*v;
0654 nov=size(C{1,1},1);
0655 <span class="keyword">if</span>(it==1)
0656    <span class="keyword">for</span> j=1:k 
0657       x=C{1,1}*w(1:nov)+C{1,2}*w(nov+1:2*nov);
0658       <span class="keyword">for</span> i=3:size(C,2)
0659           x=x+C{1,i}*w(nov*vm(i-2)-nov+1:nov*vm(i-2));
0660       <span class="keyword">end</span>
0661       w(nov+1:nov*mp)=w(1:nov*mp-nov);
0662       w(1:nov)=x;
0663    <span class="keyword">end</span> 
0664 <span class="keyword">else</span>   
0665    <span class="keyword">for</span> j=1:k
0666       w=M*w;
0667    <span class="keyword">end</span>
0668 <span class="keyword">end</span>    
0669 
0670 <a name="_sub8" href="#_subfunctions" class="code">function [w]=Powmvt(M,Q,k,v,C,vm,mp,it)</a>
0671 <span class="comment">%</span>
0672 <span class="comment">% Latest revision 02.03.2017</span>
0673 <span class="comment">%</span>
0674 <span class="comment">% compute w=Q'*M'^k*v</span>
0675 <span class="comment">%</span>
0676 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0677 w=v;
0678 nov=size(C{1,1},1);
0679 <span class="keyword">if</span>(it==1)
0680    <span class="keyword">for</span> j=1:k 
0681       x=w(1:nov); 
0682       w(1:nov*mp-nov)=w(nov+1:nov*mp);
0683       w(1:nov)=w(1:nov)+C{1,1}*x;
0684       w(nov+1:2*nov)=w(nov+1:2*nov)+C{1,2}*x;
0685       <span class="keyword">for</span> i=3:(size(C,2)-1)
0686       w(nov*vm(i-2)-nov+1:nov*vm(i-2))=w(nov*vm(i-2)-nov+1:nov*vm(i-2))+C{1,i}*x;
0687       <span class="keyword">end</span>
0688       w(nov*mp-nov+1:nov*mp)=C{1,end}*x;
0689    <span class="keyword">end</span> 
0690 <span class="keyword">else</span>
0691    <span class="keyword">for</span> j=1:k
0692       w=M'*w;
0693    <span class="keyword">end</span>    
0694 <span class="keyword">end</span>    
0695 w=Q'*w;</pre></div>
<hr><address>Generated on Tue 21-Sep-2021 01:27:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>